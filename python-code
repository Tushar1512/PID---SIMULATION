import tkinter as tk
import math
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure


# ================= PID CONTROLLER =================
class PIDController:
    def __init__(self, Kp=1.0, Ki=1.0, Kd=1.0, setpoint=50.0):
        self.Kp = float(Kp)
        self.Ki = float(Ki)
        self.Kd = float(Kd)
        self.setpoint = float(setpoint)
        self.prev_error = 0.0
        self.integral = 0.0
        self.dt = 0.1
        self.output_limits = (0, 100)

    def update(self, pv):
        error = self.setpoint - pv
        self.integral += error * self.dt
        derivative = (error - self.prev_error) / self.dt

        # Calculate individual terms
        p_term = self.Kp * error
        i_term = self.Ki * self.integral
        d_term = self.Kd * derivative

        # Calculate Combined Terms
        pd_term = p_term + d_term
        pid_total = p_term + i_term + d_term

        self.prev_error = error

        # Return all components
        return p_term, i_term, d_term, pd_term, pid_total


# ================= TRANSIENT ANALYZER =================
class TransientAnalyzer:
    def __init__(self):
        self.reset(0, 0, 0)

    def reset(self, current_time, start_pv, target_sp):
        self.start_time = current_time
        self.start_pv = start_pv
        self.target_sp = target_sp
        self.step_size = abs(target_sp - start_pv)

        # State tracking
        self.peak_pv = -9999
        self.peak_time = 0
        self.t_10 = None
        self.t_90 = None
        self.settled_time = None
        self.last_unsettled_time = current_time

        # Metrics to display
        self.rise_time = 0.0
        self.overshoot = 0.0
        self.peak_time_display = 0.0
        self.settling_time = 0.0

    def update(self, current_time, pv, sp):
        if abs(sp - self.target_sp) > 0.5:
            self.reset(current_time, pv, sp)
            return

        if self.step_size < 1.0:
            return

        t_elapsed = current_time - self.start_time

        # 1. Overshoot
        if self.target_sp > self.start_pv:
            deviation = pv - self.target_sp
            current_overshoot = (deviation / self.step_size) * 100
        else:
            deviation = self.target_sp - pv
            current_overshoot = (deviation / self.step_size) * 100

        if current_overshoot > self.overshoot:
            self.overshoot = current_overshoot
            self.peak_time_display = t_elapsed

        # 2. Rise Time
        progress = (pv - self.start_pv) / (self.target_sp - self.start_pv)
        if self.t_10 is None and progress >= 0.10:
            self.t_10 = t_elapsed
        if self.t_90 is None and progress >= 0.90:
            self.t_90 = t_elapsed
            if self.t_10 is not None:
                self.rise_time = self.t_90 - self.t_10

        # 3. Settling Time
        error_pct = abs(pv - self.target_sp) / self.step_size
        if error_pct > 0.02:
            self.last_unsettled_time = current_time
            self.settling_time = 0
        else:
            self.settling_time = self.last_unsettled_time - self.start_time


# ================= ROTARY KNOB ====================
class RotaryKnob(tk.Canvas):
    def __init__(self, master, name_label, min_val, max_val, init_val, callback, color="#b14cff"):
        super().__init__(master, width=100, height=140,
                         bg="#16213e", highlightthickness=0)

        self.min = float(min_val)
        self.max = float(max_val)
        self.value = float(init_val)
        self.callback = callback
        self.name_label = name_label
        self.color = color

        self.center_x, self.center_y = 50, 50
        self.radius = 35

        self.create_oval(self.center_x - 45, self.center_y - 45,
                         self.center_x + 45, self.center_y + 45,
                         outline=self.color, width=3)
        self.create_oval(self.center_x - 35, self.center_y - 35,
                         self.center_x + 35, self.center_y + 35,
                         fill="#1a1a2e", outline="")

        self.pointer = self.create_line(
            self.center_x, self.center_y,
            self.center_x, self.center_y - self.radius,
            width=4, fill=self.color, capstyle=tk.ROUND
        )

        self.create_text(self.center_x, 105, text=self.name_label,
                         fill=self.color, font=("Arial", 9, "bold"))
        self.value_text = self.create_text(self.center_x, 125,
                                           text=f"{self.value:.1f}",
                                           fill="#ecf0f1", font=("Arial", 9))

        self.bind("<B1-Motion>", self.rotate)
        self.update_pointer()

    def angle_from_value(self):
        return (self.value - self.min) / (self.max - self.min) * 270 - 135

    def value_from_angle(self, angle):
        return self.min + ((angle + 135) / 270) * (self.max - self.min)

    def rotate(self, event):
        dx = event.x - self.center_x
        dy = self.center_y - event.y
        angle = math.degrees(math.atan2(dy, dx))
        if angle < -135: angle = -135
        if angle > 135: angle = 135

        self.value = round(self.value_from_angle(angle), 1)
        self.callback(self.value)
        self.update_pointer()

    def update_pointer(self):
        angle = self.angle_from_value()
        rad = math.radians(angle)
        x = self.center_x + self.radius * math.cos(rad)
        y = self.center_y - self.radius * math.sin(rad)
        self.coords(self.pointer, self.center_x, self.center_y, x, y)
        self.itemconfig(self.value_text, text=f"{self.value:.1f}")


# ================= GUI ============================
class PIDGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("Combined PID Graph")
        self.root.configure(bg="#1a1a2e")
        self.root.resizable(True, True)

        self.pid = PIDController()
        self.analyzer = TransientAnalyzer()

        self.running = False
        self.process_value = 25.0

        # Data Buffers
        self.time = []
        self.data_p = []
        self.data_i = []
        self.data_d = []
        self.data_pd = []
        self.data_pid = []
        self.data_sp = []

        self.build_ui()
        self.loop()

    def build_ui(self):
        # 1. TOP FRAME (Controls + Metrics)
        top_frame = tk.Frame(self.root, bg="#16213e")
        top_frame.pack(fill=tk.X, padx=10, pady=5)

        # Controls
        control_frame = tk.Frame(top_frame, bg="#16213e")
        control_frame.pack(side=tk.LEFT, fill=tk.Y)

        RotaryKnob(control_frame, "Kp", 0, 10, self.pid.Kp,
                   lambda v: setattr(self.pid, "Kp", v)).pack(side=tk.LEFT, padx=5)
        RotaryKnob(control_frame, "Ki", 0, 10, self.pid.Ki,
                   lambda v: setattr(self.pid, "Ki", v)).pack(side=tk.LEFT, padx=5)
        RotaryKnob(control_frame, "Kd", 0, 10, self.pid.Kd,
                   lambda v: setattr(self.pid, "Kd", v)).pack(side=tk.LEFT, padx=5)
        RotaryKnob(control_frame, "SetPoint", 0, 100, self.pid.setpoint,
                   lambda v: setattr(self.pid, "setpoint", v),
                   color="#2ecc71").pack(side=tk.LEFT, padx=15)

        # Metrics Panel
        metrics_frame = tk.LabelFrame(top_frame, text=" Transient Response ",
                                      bg="#16213e", fg="#e67e22",
                                      font=("Arial", 10, "bold"), padx=10, pady=5)
        metrics_frame.pack(side=tk.LEFT, padx=20)

        self.lbl_rise = self.create_metric_label(metrics_frame, "Rise Time:", 0)
        self.lbl_peak = self.create_metric_label(metrics_frame, "Peak Time:", 1)
        self.lbl_over = self.create_metric_label(metrics_frame, "Overshoot:", 2)
        self.lbl_sett = self.create_metric_label(metrics_frame, "Settling Time:", 3)

        # Buttons
        btn_frame = tk.Frame(top_frame, bg="#16213e")
        btn_frame.pack(side=tk.RIGHT, padx=10)

        self.start_btn = tk.Button(btn_frame, text="▶ Start", bg="#2ecc71", fg="white",
                                   font=("Arial", 11, "bold"), width=8, command=self.toggle)
        self.start_btn.pack(pady=5)
        tk.Button(btn_frame, text="Reset", bg="#e67e22", fg="white",
                  font=("Arial", 11, "bold"), width=8, command=self.reset).pack(pady=5)

        # 2. PLOT AREA (Single Plot)
        self.fig = Figure(figsize=(10, 6), dpi=100, facecolor="#1a1a2e")
        self.ax = self.fig.add_subplot(111)
        self.ax.set_facecolor("#0f1526")
        self.ax.set_ylim(-20, 110)
        self.ax.set_xlim(0, 30)
        self.ax.grid(alpha=0.2, linestyle="--")

        # Create all lines on the SAME axes
        # Setpoint (Dashed Green)
        self.line_sp, = self.ax.plot([], [], "--", color="#2ecc71", lw=2, label="Setpoint", alpha=0.7)

        # Components (Thinner Lines)
        self.line_p, = self.ax.plot([], [], color="#f1c40f", lw=1.5, label="P Term", alpha=0.6)
        self.line_i, = self.ax.plot([], [], color="#3498db", lw=1.5, label="I Term", alpha=0.6)
        self.line_d, = self.ax.plot([], [], color="#9b59b6", lw=1.5, label="D Term", alpha=0.6)

        # Combined (Medium)
        self.line_pd, = self.ax.plot([], [], color="#e67e22", lw=1.5, label="PD Total", alpha=0.5, linestyle=":")

        # Final Output (Thickest)
        self.line_pid, = self.ax.plot([], [], color="#e94560", lw=3.0, label="PID Output (PV)")

        # Style
        self.ax.spines['top'].set_visible(False)
        self.ax.spines['right'].set_visible(False)
        self.ax.spines['bottom'].set_color('#bdc3c7')
        self.ax.spines['left'].set_color('#bdc3c7')
        self.ax.tick_params(colors='#bdc3c7', labelsize=10)
        self.ax.set_title("Combined System Response", color="white", fontsize=12)

        # Legend
        self.ax.legend(loc="upper right", facecolor="#16213e", edgecolor="white",
                       labelcolor="white", fontsize=9, ncol=2)

        self.canvas = FigureCanvasTkAgg(self.fig, self.root)
        self.canvas.get_tk_widget().pack(pady=10, expand=True, fill=tk.BOTH)

    def create_metric_label(self, parent, text, row):
        tk.Label(parent, text=text, bg="#16213e", fg="#bdc3c7",
                 font=("Arial", 9)).grid(row=row, column=0, sticky="w", padx=5)
        val_lbl = tk.Label(parent, text="0.00", bg="#16213e", fg="white",
                           font=("Arial", 9, "bold"))
        val_lbl.grid(row=row, column=1, sticky="e", padx=5)
        return val_lbl

    def process(self, u):
        tau = 2.0
        u_constrained = max(0, min(100, u))
        self.process_value += ((-self.process_value + u_constrained) / tau) * self.pid.dt
        return self.process_value

    def loop(self):
        if self.running:
            p, i, d, pd, pid_total = self.pid.update(self.process_value)
            self.process(pid_total)

            t = self.time[-1] + self.pid.dt if self.time else 0

            # Analyzer
            self.analyzer.update(t, self.process_value, self.pid.setpoint)

            self.lbl_rise.config(text=f"{self.analyzer.rise_time:.2f} s")
            self.lbl_peak.config(text=f"{self.analyzer.peak_time_display:.2f} s")
            self.lbl_over.config(text=f"{self.analyzer.overshoot:.1f} %")
            self.lbl_sett.config(text=f"{self.analyzer.settling_time:.2f} s")

            # Data
            self.time.append(t)
            self.data_p.append(p)
            self.data_i.append(i)
            self.data_d.append(d)
            self.data_pd.append(pd)
            self.data_pid.append(pid_total)  # This acts as PV effectively here
            self.data_sp.append(self.pid.setpoint)

            if len(self.time) > 400:
                for lst in [self.time, self.data_p, self.data_i, self.data_d,
                            self.data_pd, self.data_pid, self.data_sp]:
                    lst.pop(0)

            # Update Lines
            self.line_sp.set_data(self.time, self.data_sp)
            self.line_p.set_data(self.time, self.data_p)
            self.line_i.set_data(self.time, self.data_i)
            self.line_d.set_data(self.time, self.data_d)
            self.line_pd.set_data(self.time, self.data_pd)
            self.line_pid.set_data(self.time, self.data_pid)

            # View
            min_x = max(0, t - 30)
            max_x = max(30, t)
            self.ax.set_xlim(min_x, max_x)

            # Optional: Dynamic Y-Limit to keep everything in view
            all_data = self.data_pid + self.data_sp
            if all_data:
                y_max = max(max(all_data) + 10, 100)
                y_min = min(min(all_data) - 10, 0)
                # Ensure P/I/D terms fit too? Maybe too chaotic.
                # Let's stick to standard 0-100 range but expand if PID shoots up
                self.ax.set_ylim(min(-50, y_min), max(120, y_max))

            self.canvas.draw_idle()

        self.root.after(20, self.loop)

    def toggle(self):
        self.running = not self.running
        self.start_btn.config(text="⏸ Pause" if self.running else "▶ Start")

    def reset(self):
        self.time.clear()
        self.data_p.clear()
        self.data_i.clear()
        self.data_d.clear()
        self.data_pd.clear()
        self.data_pid.clear()
        self.data_sp.clear()
        self.process_value = 25
        self.pid.integral = 0
        self.pid.prev_error = 0
        self.analyzer.reset(0, 25, self.pid.setpoint)
        self.canvas.draw_idle()


if __name__ == "__main__":
    root = tk.Tk()
    PIDGUI(root)
    root.mainloop()
